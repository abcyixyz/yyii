[{"title":"Ubuntu-OpenCV-CPP-Without-IDE","url":"/2024/04/13/Ubuntu-OpenCV-CPP-Without-IDE/","content":"\n## Building packages\n\n1. update packages list\n\n```sh\nsudo apt update\n```\n\n2. Install building packages\n\n```sh\nsudo apt -y install build-essential\n```\n\n## Install OpenCV from Ubuntu Repositories\n\n[link](https://phoenixnap.com/kb/installing-opencv-on-ubuntu)\n\n1. Install OpenCV\n\n```sh\nsudo apt -y install libopencv-dev\n```\n\n2. Check the OpenCV version\n\n```sh\ndpkg -l libopencv-dev\n```\n\n## Install CMake\n\n```sh\nsudo apt -y install cmake\ncmake --version\n```\n\n## Create CPP Projetct\n\n[link](https://docs.opencv.org/4.x/db/df5/tutorial_linux_gcc_cmake.html)\n\n```sh\nDisplayImage\n├── build\n│   └── \n├── CMakeLists.txt\n├── cmake-modules\n│   └── OpenCVConfig.cmake\n├── img\n│   └── lenna.jpeg\n└── src\n    └── DisplayImage.cpp\n```\n\n```cpp\n// DisplayImage.cpp\n\n#include <stdio.h>\n#include <opencv2/opencv.hpp>\n\nusing namespace cv;\n\nint main(int argc, char **argv)\n{\n    if (argc != 2)\n    {\n        printf(\"usage: DisplayImage.out <Image_Path>\\n\");\n        return -1;\n    }\n\n    Mat image;\n    image = imread(argv[1], IMREAD_COLOR);\n\n    if (!image.data)\n    {\n        printf(\"No image data \\n\");\n        return -1;\n    }\n    namedWindow(\"Display Image\", WINDOW_AUTOSIZE);\n    imshow(\"Display Image\", image);\n\n    waitKey(0);\n\n    return 0;\n}\n```\n\n\n```\n# CMakeLists.txt\n\n# CMake 最低版本号要求\ncmake_minimum_required(VERSION 3.6)\n\n# 项目信息\nproject(DisplayImage)\n\n# 将cmake-modules文件夹中的文件加入 CMAKE_MODULE_PATH\nlist(APPEND CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/cmake-modules\")\n\n# 查找并从外部项目加载设置\n# REQUIRED如果找不到软件包，该选项将停止处理并显示一条错误消息\nfind_package(OpenCV REQUIRED)\n\n# 将给定目录添加到编译器用来搜索包含文件的目录中。相对路径被解释为相对于当前源目录\ninclude_directories(${OpenCV_INCLUDE_DIRS})\n\n# 利用源码文件生成目标可执行程序\nadd_executable(DisplayImage src/DisplayImage.cpp)\n\n# 添加链接库\ntarget_link_libraries(DisplayImage ${OpenCV_LIBS})\n```\n\n## Find OpenCV Config\n\n[link](https://wiki.hanzheteng.com/development/cmake/cmake-find_package)\n\n```sh\nsudo find / -name \"OpenCVConfig.cmake\"\n```\n\ncopy to cmake-modules folder\n\n## Build and Test\n\n```sh\ncd build\ncmake ..\nmake\n./DisplayImage ../img/lenna.jpeg\n```\n\nmaybe need `chmod +x DisplayImage`\n\n![test](Screenshot_test.png)\n\n\n## VSCode Debug\n\n* Install Extensions\n\n![install_Extensions](Screenshot_VSCode_Extensions.png)\n\n* restart and set cmake\n\n![set_cmake](Screenshot_set_cmake.png)\n\n* add breakpoint and click Debug button\n\n![breakpoint](Screenshot_set_breakpoint.png)\n\n* Debugging\n\n![run_debug](Screenshot_Debug.png)\n\n* set pic path for main args\n\nplease tell me...\n\n\n","tags":["Ubuntu OpenCV CMake"]},{"title":"opencv交叉编译","url":"/2024/02/25/opencv交叉编译/","content":"\n# opencv交叉编译\n\n[参考](https://www.codenong.com/cs105274123/)\n\n## 环境\n\nUbuntu 18.04 aarm64    OpenCV3.4.5  目标arm64\n\n源码\n\n OpenCV源码下载地址: https://opencv.org/releases/ \n\n安装交叉编译器\n\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n安装cmake\n\n```bash\nsudo apt install cmake cmake-gui\n```\n\n解压OpenCV\n\n## 使用cmake-gui生成Makefile\n\n![img](20200402174348844.png) \n\n![img](20200402174507776.png) \n\n![img](20200402174708819.png) \n\n\n\n![img](20200402174747432.png) \n\n![img](20200402175311654.png) \n\n查看是否生成Makefile文件\n\n## 编译\n\n```bash\nmake && make install\n```\n\n用file指令查看编译出的可执行文件\n\n```bash\nfile bin/opencv_version\n```\n\n将文件加install中生成的文件移动到aarm64文件夹，方面查找和使用。\n\n## 编译例程\n\n 在这个opencv-3.4.5/samples/cpp/example_cmake目录里官方已经给出了一个example可以拿来测试下，使用编译器编译，编译时加上OpenCV相关的库和头文件。 \n\n```bash\ng++ example.cpp -o aarm64 -I /home/yi/opencv/aarm64/include/ -L /home/yi/opencv/aarm64/lib/ -lopencv_calib3d -lopencv_objdetect -lopencv_core -lopencv_photo -lopencv_dnn -lopencv_shape -lopencv_features2d  -lopencv_stitching -lopencv_flann -lopencv_superres -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs  -lopencv_video -lopencv_imgproc -lopencv_videostab -lopencv_ml\n```\n\n库、头文件和可执行文件移动到目标板（若cmake-gui选择编译平台为gnu，即可在本地测试无需拷贝文件）\n\n## 设置动态库路径\n\n```bash\nexport LD_LIBRARY_PATH=/home/yi/opencv/aarm64/lib/:$LD_LIBRARY_PATH\n```\n\n## 运行\n\n\n```bash\n./aarm64\n```\n\n软件运行界面\n\n![1668051815828](1668051815828.png)","tags":["Ubuntu x86 交叉编译 aarm64 OpenCV 3.4.5"]},{"title":"Ubuntu安装QT交叉编译环境","url":"/2024/02/25/Ubuntu安装QT交叉编译环境/","content":"\n# Ubuntu 安装QT交叉编译环境\n\n[参考](https://blog.csdn.net/guohuaqu/article/details/109519744)\n\n需求实现再x86机器下完成对ARM64平台的程序开发\n\n## 安装ARM64编译器\n\n```bash\nsudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n查看\n\n![shell aarch64-linux-gnu-](1667790599228.png)\n\n## 安装qt开发环境\n\nqt安装包：qt-opensource-linux-x64-5.12.12.run\n\nsudo chmod +x，然后运行，就会出现图形界面，按步骤一步步安装即可。\n\n## 安装qt工具\n\nARM64交叉编译器，例如qmake、库等\n\n下载qt源码包：[qt-everywhere-src-5.12.12.tar.xz](http://download.qt.io/archive/qt/5.14/5.12.12/single/qt-everywhere-src-5.12.12.tar.xz) \n\n解压 xz -d qt-everywhere-src-5.12.12.tar.xz\n\n修改编译配置文件\n\n```bash\nyi@linux:~/Downloads/qt-everywhere-src-5.12.12/qtbase/mkspecs$ ls\naix-g++                macx-xcode\naix-g++-64             modules\nandroid-clang          modules-inst\nandroid-g++            netbsd-g++\ncommon                 openbsd-g++\ncygwin-g++             qconfig.pri\ndarwin-g++             qdevice.pri\ndevices                qmodule.pri\ndummy                  qnx-aarch64le-qcc\nfeatures               qnx-armle-v7-qcc\nfreebsd-clang          qnx-x86-64-qcc\nfreebsd-g++            qnx-x86-qcc\nhaiku-g++              solaris-cc\nhpuxi-g++-64           solaris-cc-64\nhurd-g++               solaris-cc-64-stlport\nintegrity-armv7        solaris-cc-stlport\nintegrity-armv7-imx6   solaris-g++\nintegrity-armv8-rcar   solaris-g++-64\nintegrity-x86          unsupported\nlinux-aarch64-gnu-g++  wasm-emscripten\nlinux-arm-gnueabi-g++  win32-arm64-msvc2017\nlinux-clang            win32-clang-g++\nlinux-clang-libc++     win32-clang-msvc\nlinux-g++              win32-g++\nlinux-g++-32           win32-icc\nlinux-g++-64           win32-icc-k1om\nlinux-icc              win32-msvc\nlinux-icc-32           winrt-arm64-msvc2017\nlinux-icc-64           winrt-arm64-msvc2019\nlinux-icc-k1om         winrt-arm-msvc2015\nlinux-llvm             winrt-arm-msvc2017\nlinux-lsb-g++          winrt-arm-msvc2019\nlynxos-g++             winrt-x64-msvc2015\nmacx-clang             winrt-x64-msvc2017\nmacx-g++               winrt-x64-msvc2019\nmacx-icc               winrt-x86-msvc2015\nmacx-ios-clang         winrt-x86-msvc2017\nmacx-tvos-clang        winrt-x86-msvc2019\n```\n\n查看修改配置文件 vim linux-aarch64-gnu-g++/qmake.conf\n\n```bash\n#\n# qmake configuration for building with aarch64-linux-gnu-g++\n#\n\nMAKEFILE_GENERATOR      = UNIX\nCONFIG                 += incremental\nQMAKE_INCREMENTAL_STYLE = sublib\n\ninclude(../common/linux.conf)\ninclude(../common/gcc-base-unix.conf)\ninclude(../common/g++-unix.conf)\n\n# modifications to g++.conf\nQMAKE_CC                = aarch64-linux-gnu-gcc\nQMAKE_CXX               = aarch64-linux-gnu-g++\nQMAKE_LINK              = aarch64-linux-gnu-g++\nQMAKE_LINK_SHLIB        = aarch64-linux-gnu-g++\n\n# modifications to linux.conf\nQMAKE_AR                = aarch64-linux-gnu-ar cqs\nQMAKE_OBJCOPY           = aarch64-linux-gnu-objcopy\nQMAKE_NM                = aarch64-linux-gnu-nm -P\nQMAKE_STRIP             = aarch64-linux-gnu-strip\nload(qt_config)\n```\n\n开始编译：\n\n 进入根目录cd qt-everywhere-src-5.12.12 \n\n```bash\n./configure -prefix /home/yi/Qt5.12.12/5.12.12/aarch64 -make libs -xplatform linux-aarch64-gnu-g++ -no-opengl -skip qtdeclarative\n```\n\n-prefix 代表你的安装文件夹\n\n-xplatform 代表你所制定的编译器\n\nno-opengl 跳过编译openGL(因为我已经安装了Qt，所以不需要界面)\n\n-skip qtdeclarative 跳过 qtdeclarative（不跳过，编译出错，出错的原因不清楚）\n\n线程开到了最大，并把log存在了本地。编译具体时间比较依赖自己PC的配置。\n\n```bash\nmake -j16 2>&1 | tee build.log\n```\n创建安装文件夹\n\n```bash\nMkdir -p Qt5.12.12/5.12.12/aarch64\n```\n安装\n\n```bash\nmake install\n```\n查看结果\n\n```bash\nyi@linux:~/Qt5.12.12/5.12.12/aarch64$ ls\nbin  doc  include  lib  mkspecs  plugins  translations\n```\n## 配置Qt，添加交叉编译环境\n\n4.配置Qt，添加交叉编译环境\n\na.打开Qt\n\nb.tools → options,打开面板\n\nc.设置compilers,手动添加ARM64交叉编译器\n\nadd c\n\n![commpilers](commpilers.png)\n\n\nd.手动add qt version\n\n![qt kits-Versions](1667797779321.png)\n\ne.手动add Kits\n\n![qt kits-Manual](1667797929755.png)\n\n![qt Debugger](1667797958269.png)\n\n## 新建工程&编译\n\n选择刚刚手动添加的kits\n\n","tags":["Ubuntu x86 ARM64 Qt 交叉编译"]},{"title":"Pycharm+Anaconda+QtDesigner开发完整配置攻略","url":"/2024/02/12/Pycharm-Anaconda-QtDesigner开发完整配置攻略/","content":"\n## 下载安装\npycharm\n\n## 下载安装\n[anaconda](https://repo.anaconda.com/archive/Anaconda3-2021.05-Windows-x86_64.exe)\n\nanaconda mirror\n\n## 设置pypi源\npycharm project\n\n```\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n## 安装软件包\n\n```\npip install -r requirements.txt\n```\n\n## 查看python版本\n\n```\nC:\\Users\\替换为用户名>pip -V\npip 21.0.1 from E:\\ProgramData\\Anaconda3\\lib\\site-packages\\pip (python 3.8)\n```\n\n## conda 添加中科大源\n[https://blog.csdn.net/R18830287035/article/details/90633942](https://blog.csdn.net/R18830287035/article/details/90633942)\n\n```\nC:\\Users\\替换为用户名>\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/\nconda config --set show_channel_urls yes\n```\n\n```\nC:\\Users\\替换为用户名>\nconda config --show channels\nchannels:\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n  - defaults\n```\n\n## PyCharm+Qt Designer+PyUIC安装配置教程\n\n[https://www.cnblogs.com/lsdb/p/9121903.html](https://www.cnblogs.com/lsdb/p/9121903.html)\n\n\n## pycharm Setting\n\n```\nTools - External Tools\n  Qt-QtDesigner \n    Name: QtDesigner\n    Group: Qt\n    Program: E:\\ProgramData\\Anaconda3\\envs\\py37ccd\\Lib\\site-packages\\PySide2\\designer.exe\n    Working dir: $FileDir$\n  Qt-PyUIC\n    Name: PyUIC\n    Group: Qt\n    Program: E:\\ProgramData\\Anaconda3\\envs\\py37ccd\\python.exe\n    Arguments: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py\n    Working dir: $FileDir$\n```\n\n## PyCharm+QTDesigner+PyUIC使用教程\nhttps://www.cnblogs.com/lsdb/p/9122425.html\n","tags":["PyQt 开发环境 PyCharm Anaconda Qt Designer"]},{"title":"esp32通过lvgl库驱动触摸屏","url":"/2023/08/06/esp32通过lvgl库驱动触摸屏/","content":"\n在ESP32开发板上使用LVGL框架开发LCD显示屏界面\n\n![run_demo](run_demo.png)\n\n## TFT_eSPI drive LCD\n\nhttps://github.com/Bodmer/TFT_eSPI/discussions/2555\n\nI have it working now. This wiki page was useful: https://github.com/Bodmer/TFT_eSPI/wiki/Installing-on-PlatformIO\n\nThat said, there are some missing parts that due to the state of the library will show up as a non-functioning screen. For my use case (an ILI9488 device), I needed to provide additional values. I believe some of these are necessary for all projects.\n\nHere is the bare minimum project using Visual Studio Code with PlatformIo and using the technique of platformio.ini file modification. No library file modification needed!\n\nplatformio.ini:\n```\n[env:nodemcu-32s]\nplatform = espressif32\nboard = nodemcu-32s\nframework = arduino\nmonitor_speed = 115200\nlib_deps = bodmer/TFT_eSPI@^2.5.23\nbuild_flags =\n-D USER_SETUP_LOADED\n-D ILI9488_DRIVER\n-D TFT_MISO=19\n-D TFT_MOSI=23\n-D TFT_SCLK=18\n-D TFT_CS=15\n-D TFT_DC=2\n-D TFT_RST=4\n-D LOAD_GLCD=1\n-D SMOOTH_FONT\n-D SPI_FREQUENCY=27000000\n```\n\nmain.cpp:\n```c++\n#include <Arduino.h>\n#include <TFT_eSPI.h> // Hardware-specific library\nTFT_eSPI tft = TFT_eSPI(); // Invoke custom library\n\nvoid setup()\n{\nSerial.begin(115200); // For debug\ntft.init();\n\ntft.setRotation(1);\ntft.fillScreen(TFT_GREEN);\n}\n\nvoid loop()\n{\n// put your main code here, to run repeatedly:\n}\n```\n\nNote that I had to include USER_SETUP_LOADED as well as SMOOTH_FONT.\n\nThere are some minor errors in the wiki article. It projects like we need to have an =1 but I found it works just like the include system and is not necessary.\n\n\n### my self test project, need offset.\n\nplatformio.ini:\n```c++\n[env:wesp32]\nplatform = espressif32\nboard = wesp32\nframework = arduino\nmonitor_speed = 115200\nupload_speed = 230400\nboard_build.partitions = default_16MB.csv\nboard_upload.flash_size = 16MB\nlib_deps = \n\tbodmer/TFT_eSPI@^2.5.30\n    lvgl/lvgl@^8.3.7\nbuild_flags = \n\t-D USER_SETUP_LOADED\n\t-D ST7789_DRIVER\n\t-D CGRAM_OFFSET\n\t-D TFT_MOSI=23\n\t-D TFT_SCLK=18\n\t-D TFT_DC=2\n\t-D TFT_RST=4\n\t-D LOAD_GLCD=1\n\t-D SMOOTH_FONT\n\t-D SPI_FREQUENCY=55000000\n```\n\n## lvgl\n\nmain.cpp\n```c++\n/*Using LVGL with Arduino requires some extra steps:\n *Be sure to read the docs here: https://docs.lvgl.io/master/get-started/platforms/arduino.html  */\n\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n\n/*To use the built-in examples and demos of LVGL uncomment the includes below respectively.\n *You also need to copy `lvgl/examples` to `lvgl/src/examples`. Similarly for the demos `lvgl/demos` to `lvgl/src/demos`.\n Note that the `lv_examples` library is for LVGL v7 and you shouldn't install it for this version (since LVGL v8)\n as the examples and demos are now part of the main LVGL library. */\n\n/*Change to your screen resolution*/\nstatic const uint16_t screenWidth  = 240;\nstatic const uint16_t screenHeight = 280;\n\nstatic lv_disp_draw_buf_t draw_buf;\nstatic lv_color_t buf[ screenWidth * 10 ];\n\nTFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */\n\n#if LV_USE_LOG != 0\n/* Serial debugging */\nvoid my_print(const char * buf)\n{\n    Serial.printf(buf);\n    Serial.flush();\n}\n#endif\n\n/* Display flushing */\nvoid my_disp_flush( lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p )\n{\n    uint32_t w = ( area->x2 - area->x1 + 1 );\n    uint32_t h = ( area->y2 - area->y1 + 1 );\n\n    tft.startWrite();\n    tft.setAddrWindow( area->x1, area->y1, w, h );\n    tft.pushColors( ( uint16_t * )&color_p->full, w * h, true );\n    tft.endWrite();\n\n    lv_disp_flush_ready( disp );\n}\n\nvoid setup()\n{\n    Serial.begin( 115200 ); /* prepare for possible serial debug */\n\n    String LVGL_Arduino = \"Hello Arduino! \";\n    LVGL_Arduino += String('V') + lv_version_major() + \".\" + lv_version_minor() + \".\" + lv_version_patch();\n\n    Serial.println( LVGL_Arduino );\n    Serial.println( \"I am LVGL_Arduino\" );\n\n    lv_init();\n\n#if LV_USE_LOG != 0\n    lv_log_register_print_cb( my_print ); /* register print function for debugging */\n#endif\n\n    tft.begin();          /* TFT init */\n    tft.setRotation( 4 ); /* 2:top fpc 4:bottom fpc */\n\n    lv_disp_draw_buf_init( &draw_buf, buf, NULL, screenWidth * 10 );\n\n    /*Initialize the display*/\n    static lv_disp_drv_t disp_drv;\n    lv_disp_drv_init( &disp_drv );\n    /*Change the following line to your display resolution*/\n    disp_drv.hor_res = screenWidth;\n    disp_drv.ver_res = screenHeight;\n    disp_drv.flush_cb = my_disp_flush;\n    disp_drv.draw_buf = &draw_buf;\n    lv_disp_drv_register( &disp_drv );\n\n    /* Create simple label */\n    lv_obj_t *label_top = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_top, LVGL_Arduino.c_str() );\n    lv_obj_align( label_top, LV_ALIGN_TOP_LEFT, 0, 0 );\n\n    lv_obj_t *label = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label, LVGL_Arduino.c_str() );\n    lv_obj_align( label, LV_ALIGN_CENTER, 0, 0 );\n\n    lv_obj_t *label_bottom = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_bottom, LVGL_Arduino.c_str() );\n    lv_obj_align( label_bottom, LV_ALIGN_BOTTOM_RIGHT, 0, 0 );\n\n    Serial.println( \"Setup done\" );\n}\n\nvoid loop()\n{\n    lv_timer_handler(); /* let the GUI do its work */\n    delay( 5 );\n}\n```\n\n## lvgl+touch\nplatformio.ini:\n```c++\n[env:wesp32]\nplatform = espressif32\nboard = wesp32\nframework = arduino\nmonitor_speed = 115200\nupload_speed = 230400\nboard_build.partitions = default_16MB.csv\nboard_upload.flash_size = 16MB\nlib_deps = \n\tbodmer/TFT_eSPI@^2.5.30\n    fbiego/CST816S@^1.1.0\n    lvgl/lvgl@^8.3.7\nbuild_flags = \n\t-D USER_SETUP_LOADED\n\t-D ST7789_DRIVER\n\t-D CGRAM_OFFSET\n\t-D TFT_MOSI=23\n\t-D TFT_SCLK=18\n\t-D TFT_DC=2\n\t-D TFT_RST=4\n\t-D LOAD_GLCD=1\n\t-D SMOOTH_FONT\n\t-D SPI_FREQUENCY=55000000\n```\n\nmain.cpp\n```c++\n/*Using LVGL with Arduino requires some extra steps:\n *Be sure to read the docs here: https://docs.lvgl.io/master/get-started/platforms/arduino.html  */\n\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n#include <CST816S.h>\n\n\n/*To use the built-in examples and demos of LVGL uncomment the includes below respectively.\n *You also need to copy `lvgl/examples` to `lvgl/src/examples`. Similarly for the demos `lvgl/demos` to `lvgl/src/demos`.\n Note that the `lv_examples` library is for LVGL v7 and you shouldn't install it for this version (since LVGL v8)\n as the examples and demos are now part of the main LVGL library. */\n\n/*Change to your screen resolution*/\nstatic const uint16_t screenWidth  = 240;\nstatic const uint16_t screenHeight = 280;\n\nstatic lv_disp_draw_buf_t draw_buf;\nstatic lv_color_t buf[ screenWidth * 10 ];\n\nTFT_eSPI tft = TFT_eSPI(screenWidth, screenHeight); /* TFT instance */\n\nCST816S touch(15, 4, 5, 34);\t// sda, scl, rst, irq\n\n#if LV_USE_LOG != 0\n/* Serial debugging */\nvoid my_print(const char * buf)\n{\n    Serial.printf(buf);\n    Serial.flush();\n}\n#endif\n\n/* Display flushing */\nvoid my_disp_flush( lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p )\n{\n    uint32_t w = ( area->x2 - area->x1 + 1 );\n    uint32_t h = ( area->y2 - area->y1 + 1 );\n\n    tft.startWrite();\n    tft.setAddrWindow( area->x1, area->y1, w, h );\n    tft.pushColors( ( uint16_t * )&color_p->full, w * h, true );\n    tft.endWrite();\n\n    lv_disp_flush_ready( disp );\n}\n\n/*Read the touchpad*/\nvoid my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data )\n{\n    bool touched = touch.available();\n\n    if( !touched )\n    {\n        data->state = LV_INDEV_STATE_REL;\n    }\n    else\n    {\n        data->state = LV_INDEV_STATE_PR;\n\n        /*Set the coordinates*/\n        data->point.x = touch.data.x;\n        data->point.y = touch.data.y;\n\n        Serial.print( \"Data x \" );\n        Serial.println( touch.data.x );\n\n        Serial.print( \"Data y \" );\n        Serial.println( touch.data.y );\n    }\n}\n\nvoid setup()\n{\n    Serial.begin( 115200 ); /* prepare for possible serial debug */\n\n    String LVGL_Arduino = \"Hello Arduino! \";\n    LVGL_Arduino += String('V') + lv_version_major() + \".\" + lv_version_minor() + \".\" + lv_version_patch();\n\n    Serial.println( LVGL_Arduino );\n    Serial.println( \"I am LVGL_Arduino\" );\n\n    lv_init();\n\n#if LV_USE_LOG != 0\n    lv_log_register_print_cb( my_print ); /* register print function for debugging */\n#endif\n\n    tft.begin();          /* TFT init */\n    tft.setRotation( 2 ); /* 2:top fpc 4:bottom fpc */\n\n    touch.begin();\n    Serial.print(touch.data.version);\n    Serial.print(\"\\t\");\n    Serial.print(touch.data.versionInfo[0]);\n    Serial.print(\"-\");\n    Serial.print(touch.data.versionInfo[1]);\n    Serial.print(\"-\");\n    Serial.println(touch.data.versionInfo[2]);\n\n    lv_disp_draw_buf_init( &draw_buf, buf, NULL, screenWidth * 10 );\n\n    /*Initialize the display*/\n    static lv_disp_drv_t disp_drv;\n    lv_disp_drv_init( &disp_drv );\n    /*Change the following line to your display resolution*/\n    disp_drv.hor_res = screenWidth;\n    disp_drv.ver_res = screenHeight;\n    disp_drv.flush_cb = my_disp_flush;\n    disp_drv.draw_buf = &draw_buf;\n    lv_disp_drv_register( &disp_drv );\n\n    /*Initialize the (dummy) input device driver*/\n    static lv_indev_drv_t indev_drv;\n    lv_indev_drv_init( &indev_drv );\n    indev_drv.type = LV_INDEV_TYPE_POINTER;\n    indev_drv.read_cb = my_touchpad_read;\n    lv_indev_drv_register( &indev_drv );\n\n    /* Create simple label */\n    lv_obj_t *label_top = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_top, LVGL_Arduino.c_str() );\n    lv_obj_align( label_top, LV_ALIGN_TOP_LEFT, 0, 0 );\n\n    lv_obj_t *label = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label, LVGL_Arduino.c_str() );\n    lv_obj_align( label, LV_ALIGN_CENTER, 0, 0 );\n\n    lv_obj_t *label_bottom = lv_label_create( lv_scr_act() );\n    lv_label_set_text( label_bottom, LVGL_Arduino.c_str() );\n    lv_obj_align( label_bottom, LV_ALIGN_BOTTOM_RIGHT, 0, 0 );\n\n    Serial.println( \"Setup done\" );\n}\n\nvoid loop()\n{\n    lv_timer_handler(); /* let the GUI do its work */\n    delay( 5 );\n}\n\n```\n\n# lvgl demo\n使用官方demos流程：\n\n* lv_conf.h 中 `#define LV_USE_DEMO_WIDGETS 1`\n* 将lvgl库中的demos移动到src文件夹。不然会出现`undefined reference to 'lv_demo_benchmark' `（例如lv_demo_benchmark） 这是由于lv_demo_benchmark.c未被编译导致的 把demos文件夹移动到lvgl的src目录下就行了，这样就会参与到编译中了\n* 包含头文件，例如在main.c文件中 `#include \"demos/lv_demos.h\"`\n* 初始化等参考官方例程，setup中调用demo中的函数即可。 `lv_demo_widgets();`\n\n\n## 面包板测试\n注意核对FPC座的线序(1脚的位置)\n\n| ESP32 | FPC | Function | Other             |\n| ----- | --- | -------- | ----------------- |\n| GND   | 1   | GND      |                   |\n| GND   | 2   | LED_K    | 可通过PWM调整亮度 |\n| 3V3   | 3   | VDD      | 供电              |\n| 3V3   | 4   | VDD      |                   |\n| GND   | 5   | GND      |                   |\n| GND   | 6   | GND      |                   |\n| 2     | 7   | D/C      |                   |\n| GND   | 8   | CS       | 默认拉低一直有效  |\n| 18    | 9   | SCL      | SPI_SCL           |\n| 23    | 10  | SDA      | SPI_MOSI          |\n| 32    | 11  | REST     | LCD_RST           |\n| GND   | 12  | GND      |                   |\n| 4     | 13  | TP_SCL   | I2C0_SCL          |\n| 15    | 14  | TP_SDA   | I2C0_SDA          |\n| 5     | 15  | TP_RST   | Touch_RST         |\n| 34    | 16  | TP_INT   | Touch_INT         |\n| 3V3   | 17  | VDD      |                   |\n| GND   | 18  | GND      |                   |\n\n## 使用自己设计的PCB板\nControler_ESP32_V0.1（PFC座方向反了）\n\n| ESP32        | FPC | Function | Other               |\n| ------------ | --- | -------- | ------------------- |\n| GND          | 1   | GND      |                     |\n| GND          | 2   | LED_K    | 可通过PWM调整亮度   |\n| 3V3          | 3   | VDD      | 供电                |\n| 3V3          | 4   | VDD      |                     |\n| GND          | 5   | GND      |                     |\n| GND          | 6   | GND      |                     |\n| 2            | 7   | D/C      |                     |\n| 32           | 8   | CS       |                     |\n| 18           | 9   | SCL      | SPI_SCL             |\n| 23           | 10  | SDA      | SPI_MOSI            |\n| PCA9535 IO10 | 11  | REST     | IO扩展芯片 I2C0控制 |\n| GND          | 12  | GND      |                     |\n| 4            | 13  | TP_SCL   | I2C0_SCL            |\n| 15           | 14  | TP_SDA   | I2C0_SDA            |\n| PCA9535 IO11 | 15  | TP_RST   | IO扩展芯片 I2C0控制 |\n| 34           | 16  | TP_INT   | Touch_INT           |\n| 3V3          | 17  | VDD      |                     |\n| GND          | 18  | GND      |                     |\n\n\n\n","tags":["ESP32 LVGL TOUCH TFT ST7789 CST816S"]},{"title":"局域网内Raspberry上报IP地址脚本编写及部署","url":"/2023/08/06/局域网内Raspberry上报IP地址脚本编写及部署/","content":"\n## 安装python包\n\n```bash\nsudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple netifaces\n```\n\n\n\n\n## 将脚本复制到指定的目录\n\n/usr/local/bin/send_ipaddr_broadcast.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport socket\nimport netifaces\nimport signal\nimport sys\nimport time\n\ndef send_broadcast_message(sock):\n    # 获取树莓派的IP地址\n    interfaces = netifaces.interfaces()\n    for iface in interfaces:\n        addrs = netifaces.ifaddresses(iface)\n        if netifaces.AF_INET in addrs:\n            ip = addrs[netifaces.AF_INET][0]['addr']\n            if ip.find('127.0.0.1') >= 0:\n                continue\n\n            # 发送UDP广播消息\n            broadcast_ip = '255.255.255.255'  # 广播地址\n            port = 7893  # 自定义端口号\n\n            message = \"Raspberry IP address is {}\".format(ip)\n\n            try:\n                sock.sendto(message.encode(), (broadcast_ip, port))\n            except socket.error as e:\n                print(\"Failed to send broadcast message:\", str(e))\n\ndef sigterm_handler(signal, frame):\n    # 执行清理操作，例如关闭套接字等\n    if sock:\n        sock.close()\n    sys.exit(0)\n\n# 创建非阻塞式套接字\nsock = None\ntry:\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n    sock.setblocking(0)  # 设置为非阻塞式套接字\nexcept socket.error as e:\n    print(\"Failed to create socket:\", str(e))\n    sys.exit(1)\n\n# 注册SIGTERM信号处理函数\nsignal.signal(signal.SIGTERM, sigterm_handler)\n\n# 设置等待时间间隔\nwait_interval = 5  # 5秒\n\n# 循环发送UDP广播消息\nstart_time = time.time()\nwhile True:\n    try:\n        current_time = time.time()\n        if current_time - start_time >= wait_interval:\n            send_broadcast_message(sock)\n            start_time = current_time\n        time.sleep(1)  # 休眠1秒，降低CPU使用率\n    except KeyboardInterrupt:\n        # 如果收到键盘中断信号，退出循环\n        break\n\n# 关闭套接字\nif sock:\n    sock.close()\n```\n\n\n\n\n## 新建系统服务\n\n* 将send_ipaddr_broadcast.py复制到/etc/systemd/system/\n\n```shell\n[Unit]\nDescription=Send UDP Broadcast Service\nAfter=network.target\n\n[Service]\nExecStart=/usr/local/bin/send_ipaddr_broadcast.py\n\n[Install]\nWantedBy=multi-user.target\n\n```\n\n* 开启服务\n```bash\nsudo systemctl start send_ipaddr_broadcast.service\n```\n\n* 开机自启\n```bash\nsudo systemctl enable send_ipaddr_broadcast.service\n```\n\n\n\n## 测试\n\n* 打开网络调试助手\n\n* 选择UDP模式\n\n* 选择合适的本地主机地址（非127.0.0.1）\n* 输入本地主机端口7893\n* 点击开启按钮\n* 接收设置选择：ASCII模式\n\n![test](test.png)","tags":["Raspberry IP UDP Python Shell"]},{"title":"Win10系统下配置opencv库并在QT中使用","url":"/2023/08/06/Win10系统下配置opencv库并在QT中使用/","content":"\n1. 官网组装[https://opencv.org/releases/](https://opencv.org/releases/)下载Windows环境所使用的压缩包（包含源文件和编译好的库文件）\n\n2. 将压缩包解压到本地文件夹，如G:\\\n   \n   ![opencv_file_list](opencv_file_list.png)\n   \n3. 编辑WIndow系统环境变量，增加（G:\\opencv\\build\\x64\\vc15\\bin）\n\n4. qt新建界面应用工程，使用MSCV编译器。\n\n5. qt项目文件夹处右击，选择添加库。\n\n   ![qt_add_library](qt_add_library.png)\n\n6. 外部库，下一步；\n\n7. 库文件：G:/opencv/build/x64/vc15/lib/opencv_world345.lib；包含路径：G:/opencv/build/include；勾选debug版添加'd'；下一步，完成；软件会将配置信息添加到.Pro工程文件中；\n\n   ![qt_set_project](qt_set_project.png)\n\n8. 准备一张图片，注意图片名及路径仅可使用英文字符。如G:\\opencv\\demo.png\n\n9. 修改代码mainwindow.cpp，注意文件路径\n\n```c++\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/core/core.hpp>\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    cv::Mat image = cv::imread(\"G:/opencv/demo.png\");\n    cv::namedWindow(\"My Image\");\n    cv::imshow(\"window\", image);\n//    cv::waitKey(-1);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n```\n\n10. 断点调试\n\n点击Debug按钮开始调试，会有图片及界面弹出。增加断点验证调试功能是否正常。\n","tags":["OpenCV Qt Windows10"]},{"title":"pyqt数值输入框与进度条联动","url":"/2023/08/06/pyqt数值输入框与进度条联动/","content":"\n## 背景\n\n1. QSpinBox/QDoubleSpinBox（数值输入框）：\n\n   使用`valuechange`信号，在修改数值的过程中会发送信号，如输入123，则会触发1、12、123三条信号。若是删除原有数据，产生的信号会更多。`editingFinished`在输入完成后鼠标离开控件（失去焦点）或按下回车才会触发信号。\n\n2. QSlider （进度条）：\n\n   使用`valuechange`信号，在滑块拖动过程中，信号将会被频繁发送。 如果是上位机通过串口向下位机发送指令，一般下位机（简单MCU做主控）无法响应高频率的指令。\t`released`信号只有在释放滑块时才会发送，但点击slider部件造成的滑块移动，并不会发送released信号，就造成当前滑块位置与实际参数不一致的BUG。\n\n\n\n## 控件联动和信号的产生\n\n1. 创建控件\n\n```python\n# 整数\nself.d_slider = QtWidgets.QSlider(self.xxx)\nself.d_spin_box = QtWidgets.QSpinBox(self.xxx)\n# 小数\nself.f_slider = QtWidgets.QSlider(self.xxx)\nself.f_slider = QtWidgets.QDoubleSpinBox(self.xxx)\n```\n\n\n\n2. double数值输入和整数进度条控件相互转换需特殊处理（此处固定为1个小数点）\n\n```python\ndef xx_sTb\n\tself.f_spin_box.setValue(self.f_slider.value() / 10)\n    \ndef xx_bTs\n\tself.f_slider.setValue(self.f_spin_box.value() * 10)\n```\n\n\n\n3. 实现输入框和进度条联动（信号和槽）\n\n```python\n# 整数直接相互设置\nself.d_slider.valueChanged.connect(self.d_spin_box.setValue)\nself.d_spin_box.valueChanged.connect(self.d_slider.setValue)\n\n#小数需通过函数转换\nself.f_slider.valueChanged.connect(self.xx_sTb)\nself.f_spin_box.valueChanged.connect(self.xx_bTs)\n```\n\n\n\n4. 槽函数\n\n```python\n# 槽函数\nself.event_list = [\n\tlambda: self._send_message(0), lambda: self._send_message(1)\n]\n\n# 具体操作内容\ndef _send_message(self, id: int):\n    if id == 0:\n        print(\"send0\")\n        buf = self.d_spin_box.value()  # 数值输入框的值 进度条仅为整数需放大和缩小\n    if id == 1:\n        print(\"send1\")\n        buf = self.f_spin_box.value()\n```\n\n\n\n5. 实现信号发出（信号和槽）\n\n```\n# \nself.d_slider.sliderReleased.connect(self.event_list[0])\nself.d_spin_box.editingFinished.connect(self.event_list[0])\n\nself.f_slider.sliderReleased.connect(self.event_list[1])\nself.f_spin_box.editingFinished.connect(self.event_list[1])\n\n```\n\n\n\n6. 以上实现了控件联动和信号的产生发送，但是开头提到的**滑块位置与实际参数不一致的BUG**没有解决\n\n\n\n## 解决滑块单机无信号的问题\n\n1. 安装事件过滤器\n\n```python\n# 为滑块安装过滤器\nself.d_slider.installEventFilter(self)\nself.f_slider.installEventFilter(self)\n```\n\n\n\n2. 重写事件过滤方法。将滑块的左键单击，修改为滑块释放信号\n\n```python\ndef eventFilter(self, a0: 'QObject', a1: 'QEvent') -> bool:\n    name = a0.objectName()\n    # 判断控件名称 防止与其他安装了过滤器的控件相互影响\n    if name.endswith(\"_slider\") or name.endswith(\"_dslider\"):\n        if a1.type() == a1.MouseButtonRelease and a1.button() == 1: # 判断左键\n            0.setSliderDown(True)  #模拟滑块的点击\n            a0.setSliderDown(False) #模拟滑块的点击\n            # 必需先按下后释放，才能触发sliderReleased信号\n    return False\n```\n\n\n## 结束\n","tags":["pyqt Qt Python QSlider QSpinBox QDoubleSpinBox"]},{"title":"TheengsGateway应用指南","url":"/2023/08/06/TheengsGateway应用指南/","content":"\n## Advanced users - Build and install\n\n1. 参考https://gateway.theengs.io/install/install.html#install-theengs-gateway-as-a-docker\n2. 若使用自己修改的TheengsDecoder，注意在setup.py文件中修改依赖包的版本。\n3. setup.py修改version版本号，例如`version=\"1.1.0\"`\n4. `__main__.py`调试项目，提示import失败，需将`from . import main`改为`from TheengsGateway import main`\n\n增加对串口的支持\n\n```python\n    async def serial_wr_loop(self) -> None:\n        async def read_from_serial(reader):\n            count = 0\n            self.running = True\n            while not self.stopped:\n                data = await reader.read(1000)\n                count += 1\n\n                logger.info(\n                    \"Received at `%s` from Serial: `%s`\",\n                    count,\n                    data,\n                )\n\n                data_json = {}\n                if 'None' in gw.serial_device:\n                    logger.error(\"gw.serial_device is None, please check\")\n                    self.stopped = True\n                elif 'YE600X' in gw.serial_device:\n                    # YE600X 设备调试 使用串口助手以十六进制方式发送测试数据 1e 5f 00 41 00 4b 00 e1 07 07 0c 08 0a 19 40 00 00 04 00\n                    try:\n                        data_str = bytes.decode(data, encoding='utf8')\n                        if data_str.find(\"CONNECTED\") >= 0:\n                            self.serial_mac = bytes.decode(data[data_str.find(\",\")+1:], encoding='utf8')\n                            self.serial_connect_status = \"online\"\n                            logger.info(\"serial device connected, mac: %s\", self.serial_mac)\n                        if data_str.find(\"DISCONN\") >= 0:\n                            self.serial_mac = bytes.decode(data[data_str.find(\",\")+1:], encoding='utf8')\n                            self.serial_connect_status = \"offline\"\n                            logger.info(\"serial device disconnected, mac: %s\", self.serial_mac)\n                    except:\n                        logger.info(\"serial read ascii data\")\n                    data_json[\"name\"] = \"YE600X\"\n                    data_json[\"mac\"] = self.serial_mac\n                    data_json[\"connect_status\"] = self.serial_connect_status\n                    data_json[\"manufacturerdata\"] = ''.join(['%02X' % b for b in data])\n                elif 'sps' in gw.serial_device:\n                    # sps 设备调试 使用串口助手以十六进制方式发送测试数据 af 09 7C 18 01 f9 9c 44 08\n                    data_json[\"manufacturerdata\"] = ''.join(['%02X' % b for b in data])\n                    data_json[\"id\"] = \"88:33:22:FF:44:77\"\n                    data_json[\"name\"] = \"sps\"\n                    data_json[\"rssi\"] = -15\n                else:\n                    logger.error(\"gw.serial_device is not defined, please check\")\n                    self.stopped = True\n\n                decoded_json = decodeBLE(json.dumps(data_json))  # 将python对象编码成Json字符串\n                if decoded_json is None:\n                    logger.info(\"serial decodeBLE return None\")\n                else:\n                    msg = decoded_json\n                    gw.publish(\n                        msg,\n                        gw.presence_topic,\n                    )\n            logger.error(\"serial read loop stopped\")\n            self.running = False\n\n        async def write_to_serial(writer):\n            self.running = True\n            while not self.stopped:\n                writer.write(b'off\\n')\n                await writer.drain()\n                await asyncio.sleep(2)\n            logger.error(\"serial write loop stopped\")\n            self.running = False\n        try:\n            reader, writer = await serial_asyncio.open_serial_connection(url=gw.serial_port, baudrate=115200)\n            task_1 = asyncio.create_task(read_from_serial(reader))\n            task_2 = asyncio.create_task(write_to_serial(writer))\n            await task_1\n            await task_2\n        except:\n            self.running = False\n            self.stopped = True\n            logger.error(\"serial %s port open failed, please check\", gw.serial_port)\n            \n            \ndef run(arg: str) -> None:\n    # 修改\n    thread = Thread(target=loop.run_forever, daemon=True)\n    thread.start()\n    asyncio.run_coroutine_threadsafe(gw.serial_wr_loop(), loop)\n```\n\n```python\ndef main() -> None:\n    # 增加串口端口号和目标设备类型的选项\n    parser.add_argument(\n        \"-sp\", \"--serial_port\", dest=\"serial_port\", type=str, help=\"Serial port\"\n    )\n    parser.add_argument(\n        \"-si\", \"--serial_device_id\", dest=\"serial_device\", type=str, help=\"Serial device id, need check <TheengsDecoder/src/devices/list>\"\n    )\n    # 将 serial_port  serial_device 加入配置文件的读写，并传递给 Gateway\n```\n\n","tags":["IOT Theengs Gateway Python"]},{"title":"TheengsDecoder应用指南","url":"/2023/08/06/TheengsDecoder应用指南/","content":"\n## 项目搭建\n\n1. clone工程\n2. 将下载arduino_json项目并复制到src\\arduino_json文件夹中\n3. 如果是python使用，查看https://decoder.theengs.io/use/python.html#dependencies (windows 下不用apt-get install cmake指令，在pip install . 指令脚本会自动安装依赖)\n4. 在src\\device\\中增加新的硬件解码规则，device.h中增加头文件，并加入列表\n5. decoder.h中将新硬件加入列表（BLE_ID_MAX的前面）\n6. 注意每次修改完解码规则文件，必须重新编译(例如python下使用pip install .)生效后方可测试\n\n## 测试脚本\n\n```python\nimport json\nfrom TheengsDecoder import decodeBLE as dble\n\ndata_json = {\"manufacturerdata\": \"1E5F0041004B00E107070C080A194000000400\", \"name\": \"YE600X\"}\n# data_json = {\"manufacturerdata\": \"af097C1801f99c4408\", \"name\": \"sps\"}\ndata = dble(json.dumps(data_json))\nprint(data)\n```\n\n\n\n## 新增解码规则\n\nYE600X_json.h\n\n被`/*R\"\"\"\"(`注释的代码要符合json格式\n\n删除空格回车，将`\"`前增加转义符`\\`\n\n索引编号从0开始，每个字符占一个；因为每个字符都是分开计算的，故位编号范围0-3\n\n```\nconst char* _YE600X_json = \"{\\\"brand\\\":\\\"YUWELL\\\",\n/*R\"\"\"\"(            //血压\n{\n   \"brand\":\"YUWELL\",                   //品牌：鱼跃\n   \"model\":\"BloodPressureMeters\",      //型号：血压仪\n   \"model_id\":\"YE600X\",                //型号ID：YE600X\n   \"cidc\":false,                       //起始字节不符合Bluetooth标准\n   \"condition\":[\"manufacturerdata\", \"=\", 38, \"&\", \"name\", \"index\", 0, \"YE600X\"],  //条件：name = YE600X\n   \"properties\":{\n      \"pressure_unit\":{\n         \"decoder\":[\"bit_static_value\", \"manufacturerdata\", 1, 0, \"mmHg\", \"kPa\"]  //血压单位： 第0字节 第0位  true：mmHg false：kpa\n      },\n      \"systolic_pressure\":{\n         \"decoder\":[\"value_from_hex_data\", \"manufacturerdata\", 2, 4, true]\n      }\n    }\n}\n\nconst char* _YE600X_json_props = \"{\\\"properties\\\":\n/*R\"\"\"\"(\n{\n   \"properties\":{\n      \"pressure_unit\":{\n         \"unit\":\"string\",\n         \"name\":\"contact\"\n      },\n      \"systolic_pressure\":{\n         \"unit\":\"string\",\n         \"name\":\"contact\"\n      }\n    }\n}\n```\n","tags":["IOT Theengs Decoder Python"]},{"title":"Qt创建C++动态库DLL","url":"/2023/08/06/Qt创建CPP动态库DLL/","content":"\n## Qt创建C++动态库DLL\n\n为了提高代码复用性，实现模块化开发，我们通常会对一些常用函数进行封装，通过调用动态链接库的方法实现，Qt自生便能构建共享库。\n\n### Qt新建共享库工程\n\n* 新建工程，选择动态库，命名为DynamicLibrary，实现一个简单的方法(method) : int test()\n\nDynamicLibrary_global.h\n\n```C++\n#ifndef DYNAMICLIBRARY_GLOBAL_H\n#define DYNAMICLIBRARY_GLOBAL_H\n\n#include <QtCore/qglobal.h>\n\n#if defined(DYNAMICLIBRARY_LIBRARY)\n#  define DYNAMICLIBRARY_EXPORT Q_DECL_EXPORT\n#else\n#  define DYNAMICLIBRARY_EXPORT Q_DECL_IMPORT\n#endif\n\n#endif // DYNAMICLIBRARY_GLOBAL_H\n```\n\n\n\ndynamiclibrary.h\n\n```c++\n#ifndef DYNAMICLIBRARY_H\n#define DYNAMICLIBRARY_H\n\n#include \"DynamicLibrary_global.h\"\n\nclass DYNAMICLIBRARY_EXPORT DynamicLibrary\n{\npublic:\n    DynamicLibrary();\n    int test();\n};\n\n#endif // DYNAMICLIBRARY_H\n```\n\ndynamiclibrary.cpp\n\n```C++\n#include \"dynamiclibrary.h\"\n#include <QDebug>\n\nDynamicLibrary::DynamicLibrary()\n{\n}\n\nint DynamicLibrary::test()\n{\n    qDebug() << \"Hello Qt5\";\n    int sum = 0;\n    for (int i=1; i<=100; i++) {\n        sum = sum + i;\n    }\n    qDebug() << sum;\n    return sum;\n}\n```\n\n* Build(Debug) 得到动态库`DynamicLibrary.dll`\n\n### Qt调用动态库\n\n* 新建一个控制台工程LoadDynamic，用于测试调用前面构建的动态库dll\n* 导入相关头文件，先复制头文件至工程路径下(DynamicLibrary_global.h  dynamiclibrary.h)，然后项目单击右键添加现有文件。\n* 链接库，配置pro文件，增加动态链接库的路径`LIBS += xxx\\debug\\DynamicLibrary.dll`\n* Build(Debug) 得到可执行文件\n* 运行可执行文件时需要系统找到对应的动态链接库，可以将原来生成的动态链接库拷贝至可执行文件同级目录下\n* 其他依赖文件：开始-Qt-Qt命令行，输入windeployqt xxx\\debug\\LoadDynamic.exe\n* 可执行文件路径处输入cmd，打开命令行输入LoadDynamic.exe运行\n* ldd或depends检查依赖库情况","tags":["QT CPP DLL"]},{"title":"ESP-USB-Bridge-JTAG-Debug","url":"/2022/05/08/ESP-USB-Bridge-JTAG-Debug/","content":"\n# ESP-USB-Bridge Jtag Debug\n\n## Create Project\n\n1. Open VSCode\n\n2. <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>  \n\n``` sh\nESP-IDF: Show Examples Projects\n```\n\n3. hello_world\n\n   **Create project using example hello_world**\n\n## Setup\n\n1. Select port to use (COMx)\n\n2. set device targete\n\n3. Build project\n\n4. Select flash method (JTAG)\n\n![image-20220508171334927](image-20220508171334927.png)\n\n![image-20220508171702904](image-20220508171702904.png)\n\n5. .vscode/settings.json\n\n**COMx**\n\n``` json\n{\n  \"C_Cpp.intelliSenseEngine\": \"Tag Parser\",\n  \"idf.portWin\": \"COMx\",\n  \"idf.openOcdConfigs\": [\n    \"interface/esp_usb_bridge.cfg\",\n    \"target/esp32.cfg\"\n  ],\n  \"idf.flashType\": \"JTAG\"\n}\n```\n\n\n6. <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>\n\n``` sh\nESP-IDF: OpenOCD Manager\n```\n\nstart openocd\n\n![image-20220508173310006](image-20220508173310006.png)\n\n7. [.vscode/settings.json](https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/DEBUGGING.md)\n\n``` c\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"GDB\",\n      \"type\": \"cppdbg\",\n      \"request\": \"launch\",\n      \"MIMode\": \"gdb\",\n      \"miDebuggerPath\": \"${command:espIdf.getXtensaGdb}\",\n      \"program\": \"${workspaceFolder}/build/${command:espIdf.getProjectName}.elf\",\n      \"windows\": {\n        \"program\": \"${workspaceFolder}\\\\build\\\\${command:espIdf.getProjectName}.elf\"\n      },\n      \"cwd\": \"${workspaceFolder}\",\n      \"environment\": [{ \"name\": \"PATH\", \"value\": \"${config:idf.customExtraPaths}\" }],\n      \"setupCommands\": [\n        { \"text\": \"target remote :3333\" },\n        { \"text\": \"set remote hardware-watchpoint-limit 2\"},\n        { \"text\": \"mon reset halt\" },\n        { \"text\": \"thb app_main\" },\n        { \"text\": \"flushregs\" }\n      ],\n      \"externalConsole\": false,\n      \"logging\": {\n        \"engineLogging\": true\n      }\n    }\n  ]\n}\n```\n\n## Flash And Debug\n\n1. flash\n\n![image-20220508174242796](image-20220508174242796.png)\n\n2. <kbd>F5</kbd>  \n\n   *Try more times*\n\n![image-20220508174435026](image-20220508174435026.png)\n\n3. Other\n\n  [https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/debugging.md](https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/debugging.md)\n\n## End\n\n","tags":["esp32 OpenOCD Jtag debug vscode 调试"]},{"title":"ESP-USB-Bridge","url":"/2022/05/02/ESP-USB-Bridge/","content":"\n[https://github.com/espressif/esp-usb-bridge](https://github.com/espressif/esp-usb-bridge)\n\n## Clone\n\n``` sh\ngit clone --depth 1 https://github.com/espressif/esp-usb-bridge.git\n```\n\n## VSCode\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> ESP-IDF: Open ESP-IDF Terminal\n\n1. Config\n\n``` sh\nidf.py menuconfig\n```\n\ndown: <kbd>J</kbd>   up:<kbd>K</kbd> \n\nsettings are in the \"Bridge Configuration\" sub-menu, swap  TDO/TDI target pin num.\n\n2. Build\n\n``` sh\nidf.py build\n```\n\n3. Flash\n\n``` sh\nidf.py -p PORT flash monitor\n```\n\nPORT is the serial port created by an USB-to-UART chip\n\nTips: set boot load mode\n\n![Step](set-boot-step.png)\n\n1. Reboot\n\n## Install Driver\n\nWindows Device manager\n\n![device manager 0](device-manager-0.png)\n\ninstall driver\n\n[UsbDriverTool](https://visualgdb.com/UsbDriverTool/)\n\n![install driver.png](install-driver.png)\n\ninstall success\n\n![device manager 1](device-manager-1.png)\n\n## Connect Target\n\n1. connect target mcu\n\n![concept](concept.png)\n\n1. set target mcu download mode\n\n![target mcu download mode](target-mcu-download-mode.png)\n\n1. OpenOCD connect ESP32-WROVER-E\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> ESP-IDF: Open ESP-IDF Terminal\n\n``` sh\nopenocd.exe -f interface/esp_usb_bridge.cfg -f target/esp32.cfg\n```\n\n![connect esp32 wrover](connect-esp32-wrover.png)\n\n1. use jtag flash\n\n![use jtag flash](use-jtag-flash.png)\n\n1. use serial\n\n   * Select Port  (COMx)\n\n   * ESP-IDF Monitor device\n\n   * reboot target mcu\n\n![serial test](serial-test.png)\n\n## End\n\n","tags":["ESP32 USB Bridge 制作 测试"]},{"title":"ESP32 Windows VSCode IDE","url":"/2022/05/02/ESP32-Window-VSCode/","content":"\n# ESP32 IDE Windows VSCode Extension\n\n\n\n[ESP-IDF Document](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/index.html)\n\n##  VSCode\n\n[Download](https://code.visualstudio.com/download) and install  Visual Studio Code\n\n## VSCode Extension\n\n1. [Espressif IDF](https://marketplace.visualstudio.com/items?itemName=espressif.esp-idf-extension)\n2. [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)\n3. [Native Debug](https://marketplace.visualstudio.com/items?itemName=webfreak.debug)\n\n## Install ESP-IDF\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd>  ESP-IDF: Configure ESP-IDF extension\n\nChoose installation method (EXPRESS / ADVANCED / USE EXISTING SETUP)\n\n## Creat Project\n\n<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> ESP-IDF: Show Examples Projects\n\nget-started >hello_world > Create project using example hello_world\n\n1. Select Port\n2. Set Espressif device target\n3. Build\n4. Select flash method\n5. flash device\n6. Monitor device\n\n## end","tags":["ESP32 Windows VSCode IDE 环境搭建"]},{"title":"FR-CS80 FVD Modbus Communication","url":"/2022/04/03/FR-CS80-VFD-Modbus/","content":"\n## 1. 供电\n\n![image-20220329235106376](image-20220329235106376.png)\n\n## 2. 通讯接线\n\n![image-20220329235152416](image-20220329235152416.png)\n\n![image-20220329235832966](image-20220329235832966.png)\n\n![image-20220330000913954](image-20220330000913954.png)\n\n| USB-RS422 | T-568B | VFD     |\n| --------- | ------ | ------- |\n| T+        | G/   3 | RDA(R+) |\n| T-        | G    6 | RDB(R-) |\n| R+        | B/   5 | SDA(T+) |\n| R-        | B    4 | SDB(T-) |\n\n## 3. 变频器参数设置\n\n* 首先恢复出厂设置\n\n![image-20220330001346543](image-20220330001346543.png)\n\n\n\n* 按照表格依次设置\n\n| Pr.  | 名称                 | 设定值 | 内容                                        |\n| ---- | -------------------- | ------ | ------------------------------------------- |\n| 117  | PU 通讯站号          | 1      | 从机地址                                    |\n| 118  | PU 通讯速度          | 192    | 19200pbs                                    |\n| 120  | PU 通讯奇偶校验      | 2      | 偶数校验                                    |\n| 122  | PU 通讯校验时间间隔  | 9999   | 不进行通讯断线检测                          |\n| 79   | 运行模式选择         | 0      | 网络运行模式（可切换PU/网络）               |\n| 340  | 通讯启动模式选择     | 10     | 网络运行模式（可切换PU/网络）               |\n| 342  | 通讯 EEPROM 写入选择 | 1      | PU接口写入参数仅限RAM（防止频繁写入EEPROM） |\n| 549  | 协议选择             | 1      | MODBUS RTU 协议                             |\n\n说明：\n\nmodbus通讯变频器必须工作在**网络运行模式**下（PU模式下数据可读取但无法写入）\n\n通讯调试阶段建议增加奇/偶校验（测试中遇到USB-422转换模块在无校验情况下通讯失败的情况）\n\n* 重启变频器\n\nPU、EXT 闪烁：网络运行模式时闪烁\n\n## 4. 上位机软件（Modbus Poll）设置\n\n* 通讯接口（F3）\n\n![image-20220330003925711](image-20220330003925711.png)\n\n* 寄存器读取（F8）\n\n  40009\n\n  ![image-20220402212121666](image-20220402212121666.png)\n\n  多段寄存器读取 File New\n\n  20201\n\n  ![image-20220402212313037](image-20220402212313037.png)\n\n* 寄存器写入\n\n  ![image-20220402212557637](image-20220402212557637.png)\n\n  正转：0x0002\n\n  反转：0x0004\n\n  软件支持按位改变\n\n  ![image-20220402212806410](image-20220402212806410.png)\n\n* 查看通讯log数据\n\n  ![image-20220402213119377](image-20220402213119377.png)\n\n## 5.End","tags":["MITSUBISHI 三菱 VFD 变频器 Modbus 通讯 RS485 RS422"]},{"title":"Stm32F407vet6_qboot_Ymodem","url":"/2022/03/05/Stm32F407vet6-qboot-Ymodem/","content":"\n## qboot project\n\n---\n\n1. enable onchip and w25qxx flash\n\n2. add qboot package\n\n![image-20220305212321866](image-20220305212321866.png)\n\n3. build download\n\n![image-20220305212353411](image-20220305212353411.png)\n\n\n\n## app project\n\n---\n\n1. enable onchip and w25qxx flash\n\n2. add ota_downloader\n\n   ![image-20220305213051752](image-20220305213051752.png)\n\n3. edit link.lds\n\n   0x20000 = 128k          384 = 512-128\n\n   ![image-20220305213650986](image-20220305213650986.png)\n\n3. build and download\n\n   qboot jump app\n\n   ![image-20220305214540437](image-20220305214540437.png)\n\n4. change main.c\n\n```c\n#include <rtthread.h>\n#include <board.h>\n\n#define DBG_TAG \"main\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\nint main(void)\n{\n    int count = 1;\n\n    while (count++)\n    {\n        //LOG_D(\"Hello RT-Thread!\");\n        rt_thread_mdelay(1000);\n    }\n\n    return RT_EOK;\n}\n\n#define RT_APP_PART_ADDR    0x08020000\n#define NVIC_VTOR_MASK      0xFFFFFF80\nstatic int app_vtor__reconfig(void)\n{\n    SCB->VTOR = RT_APP_PART_ADDR & NVIC_VTOR_MASK;\n\n    return 0;\n}\nINIT_BOARD_EXPORT(app_vtor__reconfig);\n\n```\n\n6. build download\n\n   qboot jump app success\n\n   ![image-20220305215300979](image-20220305215300979.png)\n\n7. **\\packages\\ota_downloader-latest\\tools\\ota_packager\\rt_ota_packaging_tool.exe**\n\n   ![image-20220305215722299](image-20220305215722299.png)\n\n8. ExtraPuTTY (PuTTY Session Manager)\n\n   ![image-20220305220535007](image-20220305220535007.png)\n\n9. Ymodem Send\n\n   ![image-20220305220451993](image-20220305220451993.png)\n\n10. System restart\n\n    Qboot erase partition app\n\n    Release firmware from download to app\n\n    Jump to applicaton \n\n    ![image-20220305220906216](image-20220305220906216.png)\n\nEnd","tags":["stm32f407vet6 qboot Ymodem PuTTY"]},{"title":"Stm32F407vet6-onchip-w25qxx-flash","url":"/2022/03/05/Stm32F407vet6-onchip-w25qxx-flash/","content":"\n## onchip\n\n---\n\n1. new project\n\nchange **drivers/board.h**\n\n```c\n/*#define BSP_USING_ON_CHIP_FLASH*/\n#define BSP_USING_ON_CHIP_FLASH\n```\n\n2. RT-Thread Setting\n\nadd packages\n\n![image-20220304203615948](image-20220304203615948.png)\n\n3. onchip flash *Tisp*\n\n![stm32f4_onchip_flash_map](stm32f4_onchip_flash_map.png)\n\n4. generated by rt-rhread **drivers/drv_flash_f4.c**\n\n![image-20220304205249004](image-20220304205249004.png)\n\n5. new source file **applications/fal_cfg.h**\n\n```c\n#ifndef _FAL_CFG_H_\n#define _FAL_CFG_H_\n\n#include <rtconfig.h>\n#include <board.h>\n\n//#define NOR_FLASH_DEV_NAME             FAL_USING_NOR_FLASH_DEV_NAME\n\n//STM32F4VET6 512K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (3*128*1024)\n/*STM32F4xxx  1024K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (7*128*1024)\n */\n\n#define STM32_FLASH_START_ADRESS_16K    (STM32_FLASH_START_ADRESS)\n#define STM32_FLASH_START_ADRESS_64K    (STM32_FLASH_START_ADRESS_16K+FLASH_SIZE_GRANULARITY_16K)\n#define STM32_FLASH_START_ADRESS_128K   (STM32_FLASH_START_ADRESS_64K+FLASH_SIZE_GRANULARITY_64K)\n\n/* ===================== Flash device Configuration ========================= */\nextern const struct fal_flash_dev stm32_onchip_flash_16k;\nextern const struct fal_flash_dev stm32_onchip_flash_64k;\nextern const struct fal_flash_dev stm32_onchip_flash_128k;\nextern struct fal_flash_dev nor_flash0;\n\n/* flash device table */\n#define FAL_FLASH_DEV_TABLE                                          \\\n{                                                                    \\\n    &stm32_onchip_flash_16k,                                         \\\n    &stm32_onchip_flash_64k,                                         \\\n    &stm32_onchip_flash_128k,                                        \\\n    /*&nor_flash0,       */                                          \\\n}\n/* ====================== Partition Configuration ========================== */\n#ifdef FAL_PART_HAS_TABLE_CFG\n//boot = (onchip_flash_16k + onchip_flash_64k) = 128k\n//dev name ===>> stm32_onchip_flash_16k\n/* partition table */\n#define FAL_PART_TABLE                                                               \\\n{                                                                                    \\\n    {FAL_PART_MAGIC_WORD,        \"bl\", \"onchip_flash_16k\",  0,  FLASH_SIZE_GRANULARITY_16K,  0}, \\\n    {FAL_PART_MAGIC_WORD,      \"bl64\", \"onchip_flash_64k\",  0,  FLASH_SIZE_GRANULARITY_64K,  0}, \\\n    {FAL_PART_MAGIC_WORD,       \"app\", \"onchip_flash_128k\", 0,  FLASH_SIZE_GRANULARITY_128K, 0}, \\\n/*    {FAL_PART_MAGIC_WORD, \"easyflash\", NOR_FLASH_DEV_NAME,          0,    512*1024, 0},*/ \\\n/*    {FAL_PART_MAGIC_WORD, \"download\", NOR_FLASH_DEV_NAME,    512*1024,    512*1024, 0},*/ \\\n/*    {FAL_PART_MAGIC_WORD,     \"file\", NOR_FLASH_DEV_NAME, 1*1024*1024, 7*1024*1024, 0},*/ \\\n}\n#endif /* FAL_PART_HAS_TABLE_CFG */\n\n#endif /* _FAL_CFG_H_ */\n```\n\n\n\n6. new  source file **applications/usr_flash.c**\n\n```c\n#include <rtthread.h>\n#include \"fal.h\"\n\nstatic int usr_flash_init(void)\n{\n    fal_init();\n    return RT_EOK;\n}\n\nINIT_ENV_EXPORT(usr_flash_init);\n```\n\n7. Build + Download\n\nPuTTY\n\n![image-20220304213533067](image-20220304213533067.png)\n\n8. debug\n\n![image-20220304214034449](image-20220304214034449.png)\n\n\n\n# W25Q64\n\n---\n\n1. change **drivers/board.h**\n\n```c\n/*#define BSP_USING_SPI1*/\n#define BSP_USING_SPI2\n/*#define BSP_USING_SPI3*/\n```\n\n2. RT-Thread Setting\n\n![image-20220304214418575](image-20220304214418575.png)\n\n![image-20220304223001519](image-20220304223001519.png)\n\n3. CubeMX Setting\n\nenable spi bus\n\n4. change **applications/usr_flash.c**\n\n```c\n#include <rtthread.h>\n#include \"drv_spi.h\"\n#include \"spi_flash_sfud.h\"\n#include \"fal.h\"\n\nstatic int usr_flash_init(void)\n{\n    rt_hw_spi_device_attach(\"spi2\", \"spi20\", GPIOE, GPIO_PIN_3);\n    if (RT_NULL == rt_sfud_flash_probe(\"norflash0\", \"spi20\")) {\n        return RT_ERROR;\n    }\n\n    fal_init();\n\n    return RT_EOK;\n}\n\nINIT_ENV_EXPORT(usr_flash_init);\n```\n\n5. copy file from **packages/fal-v0.5.0/samples/porting/fal_flash_sfud_port.c** to **applications/fal_flash_sfud_port.c**\n\n6. change fal_cfg.h\n\n```c\n#ifndef _FAL_CFG_H_\n#define _FAL_CFG_H_\n\n#include <rtconfig.h>\n#include <board.h>\n\n#define NOR_FLASH_DEV_NAME             FAL_USING_NOR_FLASH_DEV_NAME\n\n//STM32F4VET6 512K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (3*128*1024)\n/*STM32F4xxx  1024K FLASH\n#define FLASH_SIZE_GRANULARITY_16K      (4*16*1024)\n#define FLASH_SIZE_GRANULARITY_64K      (1*64*1024)\n#define FLASH_SIZE_GRANULARITY_128K     (7*128*1024)\n */\n\n#define STM32_FLASH_START_ADRESS_16K    (STM32_FLASH_START_ADRESS)\n#define STM32_FLASH_START_ADRESS_64K    (STM32_FLASH_START_ADRESS_16K+FLASH_SIZE_GRANULARITY_16K)\n#define STM32_FLASH_START_ADRESS_128K   (STM32_FLASH_START_ADRESS_64K+FLASH_SIZE_GRANULARITY_64K)\n\n/* ===================== Flash device Configuration ========================= */\nextern const struct fal_flash_dev stm32_onchip_flash_16k;\nextern const struct fal_flash_dev stm32_onchip_flash_64k;\nextern const struct fal_flash_dev stm32_onchip_flash_128k;\nextern struct fal_flash_dev nor_flash0;\n\n/* flash device table */\n#define FAL_FLASH_DEV_TABLE                                          \\\n{                                                                    \\\n    &stm32_onchip_flash_16k,                                         \\\n    &stm32_onchip_flash_64k,                                         \\\n    &stm32_onchip_flash_128k,                                        \\\n    &nor_flash0,                                                     \\\n}\n/* ====================== Partition Configuration ========================== */\n#ifdef FAL_PART_HAS_TABLE_CFG\n//boot = (onchip_flash_16k + onchip_flash_64k) = 128k\n//dev name ==>> stm32_onchip_flash_16k\n/* partition table */\n#define FAL_PART_TABLE                                                               \\\n{                                                                                    \\\n    {FAL_PART_MAGIC_WORD,        \"bl\", \"onchip_flash_16k\",  0,  FLASH_SIZE_GRANULARITY_16K,  0}, \\\n    {FAL_PART_MAGIC_WORD,      \"bl64\", \"onchip_flash_64k\",  0,  FLASH_SIZE_GRANULARITY_64K,  0}, \\\n    {FAL_PART_MAGIC_WORD,       \"app\", \"onchip_flash_128k\", 0,  FLASH_SIZE_GRANULARITY_128K, 0}, \\\n    {FAL_PART_MAGIC_WORD, \"easyflash\", NOR_FLASH_DEV_NAME,          0,     512*1024, 0}, \\\n    {FAL_PART_MAGIC_WORD,  \"download\", NOR_FLASH_DEV_NAME,    512*1024,    512*1024, 0}, \\\n    {FAL_PART_MAGIC_WORD,      \"file\", NOR_FLASH_DEV_NAME, 1*1024*1024, 7*1024*1024, 0}, \\\n}\n#endif /* FAL_PART_HAS_TABLE_CFG */\n\n#endif /* _FAL_CFG_H_ */\n```\n\n7. Build + Download\n\n8. debug\n\nfal test\n\n![image-20220304225042638](image-20220304225042638.png)","tags":["STM32 onchip w25qxx flash"]},{"title":"Stm32F407_PWM_External_Sync","url":"/2022/01/18/Stm32F407-PWM-External-Sync/","content":"# Stm32F407_PWM_External_Sync\n\npwm 与 外部触发信号同步\n\n---\n\n1. new progect\n\n2. CubeMX Setting\n\n   * RCC->Cystal\n\n   * SYS->Serial Wire\n\n   * Clock Configuration->168\n\n   * TIM1\n\n     ![image-20220118205730219](image-20220118205730219.png)\n\n     ![image-20220118205737972](image-20220118205737972.png)\n\n     ![image-20220118205747601](image-20220118205747601.png)\n\n     ![image-20220118205752456](image-20220118205752456.png)\n\n     ![image-20220118205757553](image-20220118205757553.png)\n\n   * Save\n\n## Code\n\n---\n\n```c\nint main(void)\n{\n  /* USER CODE BEGIN 1 */\n\n  /* USER CODE END 1 */\n\n  /* MCU Configuration--------------------------------------------------------*/\n\n  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */\n  HAL_Init();\n\n  /* USER CODE BEGIN Init */\n\n  /* USER CODE END Init */\n\n  /* Configure the system clock */\n  SystemClock_Config();\n\n  /* USER CODE BEGIN SysInit */\n\n  /* USER CODE END SysInit */\n\n  /* Initialize all configured peripherals */\n  MX_GPIO_Init();\n  MX_TIM1_Init();\n  /* USER CODE BEGIN 2 */\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);\n  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);\n  /* USER CODE END 2 */\n\n  /* Infinite loop */\n  /* USER CODE BEGIN WHILE */\n  while (1)\n  {\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n  }\n  /* USER CODE END 3 */\n}\n```\n\n\n\n## Test\n\n---\n\n![image-20220118212029035](image-20220118212029035.png)\n\n\n\n![image-20220118212038552](image-20220118212038552.png)\n\n## END\n\n","tags":["stm32 pwm external sync"]},{"title":"Stm32F407_PWM_Master_Slave","url":"/2022/01/18/Stm32F407-PWM-Master-Slave/","content":"# Stm32F407_PWM_Master_Slave\n\n主从定时器产生确定数量的PWM脉冲\n\n---\n\n1. new progect \n\n2. CubeMX Setting\n\n  * RCC->Crystal\n\n  * SYS->Serial Wire\n\n  * Clock Configuration->168\n\n  * TIM4\n\n    ![image-20220118201958020](image-20220118201958020.png)\n\n    ![image-20220118202025867](image-20220118202025867.png)\n\n    ![image-20220118202048425](image-20220118202048425.png)\n\n  * TIM2\n\n    ![image-20220118202135289](image-20220118202135289.png)\n\n    ![image-20220118202142804](image-20220118202142804.png)\n\n    ![image-20220118202148330](image-20220118202148330.png)\n\n    ![image-20220118203457549](image-20220118203457549.png)\n\n  * Save\n\n## Code\n\n---\n\n1. main.c\n\n   ```c\n   /* USER CODE BEGIN 0 */\n   void generate_pulse(uint32_t value)\n   {\n   \tif(!value)\n   \t\treturn;\n   \t__HAL_TIM_SET_AUTORELOAD(&htim2,value-1); //设置要输出的PWM脉冲\n   \tHAL_TIM_Base_Start_IT(&htim2);             //启动从定时器\n   \t__HAL_TIM_SET_COUNTER(&htim4, 0);\n   \tHAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);  //启动主定时器PWM输出\n   }\n   \n   void  HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n   {\n       if(htim == &htim2)\n       {\n           if(__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_CC2) != RESET)  //判断是否触发中断\n           {\n               __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_CC2);      //清除中断标志\n               HAL_TIM_PWM_Stop(&htim4, TIM_CHANNEL_2);   //关闭主定时器\n               HAL_TIM_Base_Stop_IT(&htim2);         //关闭从定时器\n           }\n       }\n   }\n   /* USER CODE END 0 */\n   \n   int main(void)\n   {\n     /* USER CODE BEGIN 1 */\n   \n     /* USER CODE END 1 */\n   \n     /* MCU Configuration--------------------------------------------------------*/\n   \n     /* Reset of all peripherals, Initializes the Flash interface and the Systick. */\n     HAL_Init();\n   \n     /* USER CODE BEGIN Init */\n   \n     /* USER CODE END Init */\n   \n     /* Configure the system clock */\n     SystemClock_Config();\n   \n     /* USER CODE BEGIN SysInit */\n   \n     /* USER CODE END SysInit */\n   \n     /* Initialize all configured peripherals */\n     MX_GPIO_Init();\n     MX_TIM2_Init();\n     MX_TIM4_Init();\n     /* USER CODE BEGIN 2 */\n   \n     /* USER CODE END 2 */\n   \n     /* Infinite loop */\n     /* USER CODE BEGIN WHILE */\n     while (1)\n     {\n       /* USER CODE END WHILE */\n   \n       /* USER CODE BEGIN 3 */\n   \tgenerate_pulse(10);\n   \tHAL_Delay(1000);\n     }\n     /* USER CODE END 3 */\n   }\n   ```\n\n   ## Test\n\n   ![image-20220118202840364](image-20220118202840364.png)","tags":["stm32 pwm master slave 可控数量"]},{"title":"Stm32F407-ADC-DMA","url":"/2021/11/12/Stm32F407-ADC-DMA/","content":"\n# Stm32F407_ADC_DMA\n\n## Rt-Thrad Studio\n\n---\n\n![image-20211112222940162](image-20211112222940162.png)\n\n## CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)\n2. System Core >> SYS >> Debug(选择调试接口)\n3. Connectivity >> USART3 >> Asynchronous(用于finsh命令行)\n4. Analog >> ADC1 >>\n\nParameter Settings\n\n![image-20211112224235969](image-20211112224235969.png)\n\n![image-20211112224811725](image-20211112224811725.png)\n\n5. Analog >> ADC1 >> DMA Settings\n\n![image-20211112233043884](image-20211112233043884.png)\n\n6. Clock Configuration(配置时钟)  HCLK >> 168 >> Enter\n\n![image-20211111212633234](image-20211111212633234.png)\n\n7. GENERATE COED (default seting)\n\n![image-20211112225130880](image-20211112225130880.png)\n\n## Code\n\n---\n\n1. applications/main.c\n\n```c\n#include <rtthread.h>\n\n#define DBG_TAG \"main\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\nextern void usr_board_init(void);\nextern uint16_t read_adc_value(uint8_t channel);\n\nint main(void)\n{\n    int count = 1;\n\n    usr_board_init();\n\n    while (count++)\n    {\n        LOG_D(\"Hello RT-Thread!\");\n        rt_kprintf(\"PA3_adc = %d   \", read_adc_value(0));\n        rt_kprintf(\"PA4_adc = %d   \", read_adc_value(1));\n        rt_kprintf(\"PA5_adc = %d   \", read_adc_value(2));\n        rt_kprintf(\"PA6_adc = %d   \", read_adc_value(3));\n        rt_kprintf(\"\\n\");\n        rt_thread_mdelay(1000);\n    }\n\n    return RT_EOK;\n}\n```\n\n2. cubemx/Src/main.c\n\n```c\n/* USER CODE BEGIN 0 */\n\n#define ADC_CHANNEL_SUM         4\n#define ADC_BUFF_LOOP           30\nuint16_t adc_dma_value[ADC_CHANNEL_SUM * ADC_BUFF_LOOP];\n\nvoid usr_board_init(void)\n{\n    MX_DMA_Init();\n    MX_ADC1_Init();\n    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&adc_dma_value, ADC_CHANNEL_SUM * ADC_BUFF_LOOP);\n}\n\nuint16_t read_adc_value(uint8_t channel)\n{\n    if (channel < ADC_CHANNEL_SUM) {\n        return adc_dma_value[channel];\n    }\n    return 0;\n}\n/* USER CODE END 0 */\n\n/**\n  * Enable DMA controller clock\n  */\nstatic void MX_DMA_Init(void)\n{\n\n  /* DMA controller clock enable */\n  __HAL_RCC_DMA2_CLK_ENABLE();\n\n  /* DMA interrupt init */\n  /* DMA2_Stream0_IRQn interrupt configuration */\n  //HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);\n  //HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);\n\n}\n```\n\n## Build && Test\n\nPA3_adc\n\n![image-20211112233634255](image-20211112233634255.png)\n\n---\n\n## End","tags":["stm32 ADC DMA rt-thread studio"]},{"title":"Stm32F407_W25Q64_easyFlash","url":"/2021/11/11/Stm32F407-W25Q64-easyFlash/","content":"\n## RT-Thread Studio\n\n---\n\n1. new project\n\n![image-20211111213804740](image-20211111213804740.png)\n\n## CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)  \n2. System Core >> SYS >> Debug(选择调试接口)   \n3. Connectivity >> USART3 >> Asynchronous(用于finsh命令行)  \n4. Connectivity >> SPI2 >> Full-Dupex Master(Flash W25Q64)\n\n![image-20211111212434054](image-20211111212434054.png)\n\n5. Clock Configuration(配置时钟)\n\n   HCLK >> 168  >> Enter\n\n![image-20211111212633234](image-20211111212633234.png)\n\n6. GENERATE COED (default seting)\n\n![image-20211111212753066](image-20211111212753066.png)\n\n![image-20210630224307585](image-20210630224307585.png)\n\n## RT-Thread Setting\n\n---\n\n1. Packages >> add >> EasyFlash\n\n![image-20211111234323900](image-20211111234323900.png)\n\n2. Drivers >> SPI\n\n3. Drivers >> SPI >> SFUD\n\n   ![image-20211111234429187](image-20211111234429187.png)\n\n## Code\n\n---\n\n1. *drivers/board.h*\n\n```c\n#define BSP_USING_UART3\n#define BSP_UART3_TX_PIN       \"PD8\"\n#define BSP_UART3_RX_PIN       \"PD9\"\n\n#define BSP_USING_SPI2\n```\n\n2. *new source file*\n\n   applications/usr_flash.c   (change cs pin and bus name)\n\n```c\n#include <rtthread.h>\n#include <drv_spi.h>\n#include \"spi_flash.h\"\n#include \"spi_flash_sfud.h\"\n\nrt_spi_flash_device_t w25q64;\n\nstatic int rt_hw_spi_flash_with_sfud_init(void)\n{\n    rt_hw_spi_device_attach(\"spi2\", \"spi20\", GPIOE, GPIO_PIN_3);\n\n    /* init w25q64 */\n    if (w25q64 == rt_sfud_flash_probe(\"w25q64\", \"spi20\"))\n    {\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(rt_hw_spi_flash_with_sfud_init);\n```\n\n3. copy file \n\n   packages\\EasyFlash-v4.1.0\\ports\\ef_sfud_port.c  >>  applications/usr_flash.c\n\n## Build && Test\n\n   ![image-20211112221002533](image-20211112221002533.png)\n\n---\n\n## End","tags":["stm32 flash w25q64 easyFlash rt-thread studio"]},{"title":"Stm32F407_USB_OTG_HS","url":"/2021/07/01/Stm32F407-USB-OTG-HS/","content":"\n[github progect](https://github.com/abcyixyz/Stm32F407_USB_OTG_HS)\n\n## RT-Thread Studio\n\n---\n\n1. New >> RT-Thread Protect  \n\n![image-20210630223400016](image-20210630223400016.png)\n\n\n\n## CubeMX Settings\n\n---\n\n1. System Core >> RCC >> HSE >> Crystal(外部晶振)  \n2. System Core >> SYS >> Debug(选择调试接口)   \n3. Connectivity >> USART1 >> Asynchronous(用于finsh命令行)  \n4. Connectivity >> USB_OTG_HS >> Host_Only(开发板无供电控制故未勾选VBUS)  \n\n![image-20210630223923547](image-20210630223923547.png)\n\n1. Enable HS global interrupt\n\n![image-20210630223948843](image-20210630223948843.png)\n\n6. Clock Configuration(配置时钟)\n\n   HCLK >> 168  >> Enter\n\n![image-20210630224636418](image-20210630224636418.png)\n\n7. GENERATE COED (default seting)\n\n![image-20210630224256382](image-20210630224256382.png)\n\n![image-20210630224307585](image-20210630224307585.png)\n\n\n\n## Code\n\n---\n\n1. *applications/main.c*\n\n```c\n#define DBG_TAG \"main\"\n//#define DBG_LVL DBG_INFO\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n```\n\n2. *drivers/board.h*\n\n```c\n#define BSP_USING_UART1\n#define BSP_UART1_TX_PIN       \"PA9\"\n#define BSP_UART1_RX_PIN       \"PA10\"\n\n#define BSP_USING_USBHOST\n#define BSP_USBD_TYPE_HS\n```\n\n3. *drivers/drv_clk.c* (copy from *cubemx/Src/main.c*)\n\n```c\nvoid SystemClock_Config(void)\n{\n  RCC_OscInitTypeDef RCC_OscInitStruct = {0};\n  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};\n\n  /** Configure the main internal regulator output voltage\n  */\n  __HAL_RCC_PWR_CLK_ENABLE();\n  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);\n  /** Initializes the RCC Oscillators according to the specified parameters\n  * in the RCC_OscInitTypeDef structure.\n  */\n  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;\n  RCC_OscInitStruct.HSEState = RCC_HSE_ON;\n  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;\n  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;\n  RCC_OscInitStruct.PLL.PLLM = 25;\n  RCC_OscInitStruct.PLL.PLLN = 336;\n  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;\n  RCC_OscInitStruct.PLL.PLLQ = 7;\n  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)\n  {\n    Error_Handler();\n  }\n  /** Initializes the CPU, AHB and APB buses clocks\n  */\n  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK\n                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;\n  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;\n\n  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)\n  {\n    Error_Handler();\n  }\n}\n\n//void system_clock_config(int target_freq_mhz)\n//{\n//...\n//}\n```\n\n4. new source file  \n\n![image-20210630224927209](image-20210630224927209.png)\n\n5. `applications/filesystem.c`\n\n```C\n#include <rtthread.h>\n#include <dfs_fs.h>\n#include \"dfs_romfs.h\"\n\n#define DBG_TAG \"app.filesystem\"\n#define DBG_LVL DBG_INFO\n#include <rtdbg.h>\n\nstatic const struct romfs_dirent _romfs_root[] = {\n    {ROMFS_DIRENT_DIR, \"udisk\", RT_NULL, 0}\n};\n\nconst struct romfs_dirent romfs_root = {\n    ROMFS_DIRENT_DIR, \"/\", (rt_uint8_t *)_romfs_root, sizeof(_romfs_root) / sizeof(_romfs_root[0])\n};\n\nint mount_init(void)\n{\n    if (dfs_mount(RT_NULL, \"/\", \"rom\", 0, &(romfs_root)) != 0)\n    {\n        LOG_E(\"rom mount to '/' failed!\");\n        return RT_ERROR;\n    }\n    return RT_EOK;\n}\nINIT_APP_EXPORT(mount_init); \n```\n\n6. drivers/drv_common.c\n\n[STM32F407遇到USB读取U盘无法读取问题](https://club.rt-thread.org/ask/question/427531.html)\n\n```C\nvoid HAL_Delay(__IO uint32_t Delay)\n{\n    rt_thread_mdelay(Delay);\n}\n```\n\n7. drivers/drv_usbh.c\n\n```c\n#define DBG_TAG \"drv_usbh\"\n#define DBG_LVL DBG_LOG\n#include <rtdbg.h>\n\n/* add OTG_HS_IRQ */\nvoid OTG_HS_IRQHandler(void)\n{\n    rt_interrupt_enter();\n    HAL_HCD_IRQHandler(&stm32_hhcd_fs);\n    rt_interrupt_leave();\n}\n\n/* cubemx/Src/main.c >> static void MX_USB_OTG_HS_HCD_Init(void) */\n#ifdef BSP_USBD_TYPE_HS\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_HS;\n    hhcd->Init.Host_channels = 12;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = USB_OTG_EMBEDDED_PHY;\n    hhcd->Init.Sof_enable = DISABLE;\n    hhcd->Init.low_power_enable = DISABLE;\n    hhcd->Init.vbus_sensing_enable = DISABLE;\n    hhcd->Init.use_external_vbus = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n\n#else\n\nstatic rt_err_t stm32_hcd_init(rt_device_t device)\n{\n    HCD_HandleTypeDef *hhcd = (HCD_HandleTypeDef *)device->user_data;\n    hhcd->Instance = USB_OTG_FS;\n    hhcd->Init.Host_channels = 8;\n    hhcd->Init.speed = HCD_SPEED_FULL;\n    hhcd->Init.dma_enable = DISABLE;\n    hhcd->Init.phy_itface = HCD_PHY_EMBEDDED;\n    hhcd->Init.Sof_enable = DISABLE;\n    RT_ASSERT(HAL_HCD_Init(hhcd) == HAL_OK);\n    HAL_HCD_Start(hhcd);\n#ifdef USBH_USING_CONTROLLABLE_POWER\n    rt_pin_mode(USBH_POWER_PIN, PIN_MODE_OUTPUT);\n    rt_pin_write(USBH_POWER_PIN, PIN_LOW);\n#endif\n    return RT_EOK;\n}\n#endif\n```\n\n\n\n## RT-Thread Settings\n---\n\n1. Exclude from Build\n\n~~cubemx/Src/main.c~~  \n~~cubemx/Src/stm32f4xx_it.c~~  \n\n![image-20210630224537429](image-20210630224537429.png)\n\n![image-20210630225754496](image-20210630225754496.png)\n\n2. Components >> Device Drivers >> Using USB >> Using USB host >> Enable Udisk Drivers >> Udisk mount dir >> /udisk\n\n![image-20210630225432224](image-20210630225432224.png)\n\n3. Components >> Device virtual file system >> Using device virtual file system >> Enable elm-chan fatfs  /  Enable ReadOnlay file system on flash\n\n![image-20210630225517213](image-20210630225517213.png)\n\n## Test\n\n---\n1. Build and Flash download\n2. Terminal\n\n<kbd>Ctrl</kbd>+<kbd>Atl</kbd>+<kbd>Shift</kbd> +<kbd>T</kbd>\n\n![image-20210630225624874](image-20210630225624874.png)\n\n3. Insert the u-disk(插入U盘)\n\n![image-20210630225644852](image-20210630225644852.png)\n\n## End","tags":["stm32 usb-otg-hs u-disk rt-thread studio"]},{"title":"Archlinux下rCore 实验环境配置","url":"/2021/03/21/Archlinux下rCore-实验环境配置/","content":"Archlinux下rCore 实验环境配置\n\n原文：[rCore-Tutorial-Book 第三版 实验环境配置](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#rust)\n\n+ 系统环境配置（使用Archlinux）\n+ Rust开发环境配置\n+ Qemu模拟器安装\n+ GDB 调试支持\n\n## Rust 开发环境配置\n\n首先安装Rust包管理器cargo和Rust版本管理器rustup\n\n```bash\nsudo pacman -S cargo\nsudo pacman -S rustup\n```\n\n修改Rust Crates源 [ustc](https://mirrors.ustc.edu.cn/help/crates.io-index.html)，在 `$HOME/.cargo/config` 中添加如下内容：\n\n```bash\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n可通过如下命令安装rustc的nightly版本（rCore要求用rustc的nightly版本），并把该版本设置为rustc的缺省版本\n\n```bash\nrustup install nightly\nrustup default nightly\n```\n\n接下来安装一些Rust相关的软件包\n\n```bash\nrustup target add riscv64gc-unknown-none-elf\ncargo install cargo-binutils\nrustup component add llvm-tools-preview\nrustup component add rust-src\n```\n\n## Qemu 模拟器安装\n\n```bash\nsudo pacman -S qemu-emulators-full\n```\n\n随后即可在当前终端 `source ~/.bashrc` 更新系统路径，或者直接重启一个新的终端。此时我们可以确认 Qemu 的版本\n\n```bash\nqemu-system-riscv64 --version\nqemu-riscv64 --version\n```\n\n## GDB 调试支持\n\n在 `os` 目录下 `make debug` 可以调试我们的内核，这需要安装终端复用工具 `tmux` ，还需要基于 riscv64 平台的 gdb 调试器 `riscv64-unknown-elf-gdb` 。该调试器包含在 riscv64 gcc 工具链中。\n\n```bash\nyay -S riscv64-unknown-elf-gdb\n```\n\n## 运行 rCore-Tutorial-v3\n\n如果是在 Qemu 平台上运行，只需在`os`目录下 `make run` 即可。在内核加载完毕之后，可以看到目前可以用的 应用程序。 `usertests` 打包了其中的很大一部分，所以我们可以运行它，只需输入在终端中输入它的名字即可。运行后，可以先按下 `Ctrl+A` ，再按下 `X` 来退出 Qemu。","tags":["rCore Rust Qemu GDB Archlinux"]},{"title":"Mosquitto 搭建及配置","url":"/2021/03/21/Mosquitto-搭建及配置/","content":"# Mosquitto 搭建及配置\n\nEclipse Mosquitto是一个开源消息代理，实现了MQTT协议版本3.1和3.1.1。Mosquitto轻量，适用于低功耗单板计算机到完整服务器的所有设备。Mosquitto项目还提供了用于实现MQTT客户端的C库以及非常受欢迎的mosquitto_pub和mosquitto_sub命令行MQTT客户端。\n\n其他服务器代理实现:https://github.com/mqtt/mqtt.github.io/wiki/servers\n 各操作系统安装指引:https://mosquitto.org/download/\n\n#### 1. 下载安装\n\n以Ubuntu为例\n\n- 更新源\n\n```bash\nsudo apt-get update\n```\n\n- 安装服务器端\n\n```bash\nsudo apt-get install mosquitto\n```\n\n+ 安装客户端\n\n```bash\nsudo apt-get install mosquitto-clients\n```\n\n#### 2. 配置\n\n##### 2.1 主配置文件mosquitto.conf\n\n```nginx\nid_file /var/run/mosquitto.pid\n\n# 消息持久存储\npersistence true\npersistence_location /var/lib/mosquitto/\n\n# 日志文件\nlog_dest file /var/log/mosquitto/mosquitto.log\n\n# 其他配置\ninclude_dir /etc/mosquitto/conf.d\n\n# 禁止匿名访问\nallow_anonymous false\n# 认证配置\npassword_file /etc/mosquitto/pwfile\n# 权限配置\nacl_file /etc/mosquitto/aclfile\n```\n\n##### 2.2 认证配置pwfile\n\n- 创建密码存储文件\n\n```bash\nsudo touch /etc/mosquitto/pwfile\n```\n\n- 服务开启后,输入如下命令,根据提示输入两遍密码\n\n```bash\nmosquitto_passwd /etc/mosquitto/pwfile 用户名\n```\n\n##### 2.3 权限配置aclfile\n\n- 打开文件\n\n```bash\nvim /etc/mosquitto/aclfile\n```\n\n- 编辑内容\n\n```nginx\n# 李雷只能发布以test为前缀的主题,订阅以$SYS开头的主题即系统主题\nuser lilei\ntopic write test/#\ntopic read $SYS/#\n\n# 韩梅梅只能订阅以test为前缀的主题\nuser hanmeimei\ntopic read test/#\n```\n\n#### 3. 启动\n\n-c：指定特定配置文件启动\n-d：后台运行\n\n```bash\nmosquitto -c /etc/mosquitto/mosquitto.conf -d\n```\n\n#### 4. 测试\n\n发布使用mosquitto_pub命令，订阅使用mosquitto_sub命令。常用参数介绍：\n\n| 参数 | 描述                      |\n| ---- | ------------------------- |\n| -h   | 服务器主机，默认localhost |\n| -t   | 指定主题                  |\n| -u   | 用户名                    |\n| -P   | 密码                      |\n| -i   | 客户端id，唯一            |\n| -m   | 发布的消息内容            |\n\n订阅\n\n```bash\nmosquitto_sub -h localhost -t \"test/#\" -u hanmeimei -P 123456 -i \"client1\"\n```\n\n订阅系统主题\n\n```bash\n# 订阅客户端存活连接数\nmosquitto_sub -h localhost –t '$SYS/broker/clients/active' -u lilei -P 123456 -i \"client2\"\n```\n\n发布\n\n```bash\nmosquitto_pub -h localhost -t \"test/abc\" -u lilei -P 123456 -i \"client3\" -m \"How are you?\"\n```\n\n##### 链接\n\n- 项目网站：https://www.eclipse.org/paho\n- Eclipse项目信息：https://projects.eclipse.org/projects/iot.paho\n- GitHub：https://github.com/eclipse/paho.mqtt.java\n- MQTT Java客户端的使用：https://www.jianshu.com/p/65e1748a930c\n- Spring支持：https://www.jianshu.com/p/6b60858b7d44","tags":["mqtt server"]},{"title":"Gitblit 安装使用","url":"/2020/11/22/Gitblit-安装使用/","content":"\n[Gitblit](https://gitblit.github.io/gitblit/) is an open-source, pure Java stack for managing, viewing, and serving Git repositories.\nIt's designed primarily as a tool for small workgroups who want to host centralized repositories.\n\n Gitblit是一个在Java环境中运行的Git服务器。在这里记录一下搭建过程。\n\n# 准备文件\n\n* jdk-11.0.2_windows-x64_bin.zip[华为源](https://repo.huaweicloud.com/java/jdk/)\n* gitblit安装包[Gitblit](https://gitblit.github.io/gitblit/)\n\n# 安装Java\n请参考[菜鸟教程](https://www.runoob.com/java/java-environment-setup.html)\n\n# 配置Gitblit\n1. 下载的zip文件只要解压缩即可，不用安装。建议放到D:\\Program Files\\gitblit-xxx目录中（xxx指版本号）\n2. 新建一个用于存放git服务器数据的文件夹，如D:\\GitBlit_repository\n3. 配置gitblit.properties 文件。  \n    * 在D:\\Program Files\\gitblit-xxx\\data目录中将defaults.properties文件复制一份，改名为my.properties  \n    * 修改gitblit.properties文件，然后将 `include = defaults.properties` 注释掉  \n    * 添加一代码`include = my.properties`表示使用my.properties这个配置。  \n4. 修改my.properties文件中的端口和服务器IP地址：  \n    * 修改git.repositoriesFolder = D:/Gitblit_repository（注意其中的D:\\Gitblit_repository 中的\"\\\"一定要用\"/\"。）  \n    * 修改server.httpPort = 10101  \n    * 修改server.httpBindInterface = 192.168123.15（我自己的服务器IP地址为192.168.123.15）  \n    * 修改server.httpsBindInterface = localhost  \n    * 最后修改server.certificateAlias = localhost\n5. 运行Gitblit服务。在D:\\Program Files\\gitblit-xxx目录下运行gitblit.cmd命令。注意看命令行中的提示，检查程序是否运行正常。\n6. 命令行中会有服务器ip和端口号请注意查看。\n\n# 管理GitBlit\n在浏览器地址栏中输入命令行中提示的服务器ip和端口号\n如果成功加载，说明服务器搭建完毕。默认账号密码均为admin\n\n# 设置开启自启动\n设置以Windows Service方式启动Gitblit.  \n1. 在Gitblit目录下，找到installService.cmd文件。鼠标右键使用记事本打开。  \n2. 设置 CD 为程序目录 `SET CD=D:\\Program Files\\gitblit-xxx(xxx修改为你自己的目录)`  \n3. 保存，关闭文件\n4. 右键installService.cmd文件，选择以管理员的身份运行  \n5. 点击开始菜单输入services.msc 打开Windows服务查找gitblit，如果未启动，请手动启动。注意确保为自动模式，这样每次windows启动后都自动启动此项服务。","tags":["Gitblit Windows git server 局域网"]},{"title":"Hello World","url":"/2020/05/24/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]